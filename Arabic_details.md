# pyknow??.
قبل النهاية

يوم تم تأجيله كثيرا مع "بايثون المعرفة"

اليوم بايثون من وجهة نظر المحبوبة السيئة "برلوغ"
```
PROLOG,
programmation en logique
```
ليست ليسب الان.

بايثون ورحلتها الصغيرة مع النظم الخبيرة
المنطق.؟
رحلة ليست واضحة المعالم بالنسبة للكثيرين.

تجربة
الكثير جدا  من الوقت امضيته في محاولة بناء الية يمكن استخدامها في استخلاص المعرفة 
الطرق التي اتبعتها هي استخدام

# nltk
كمساعد بشكل اساسي في وضع اطار لعمل المكتبة بشكل اوسع
كانت محاولة دمج اسلوب البحث المتقدم ب استخدام
# knn
 
وكان مرجح استخدام
# svm 
مستقبلا.
والعودة كانت بناء محرك بشكل مختصر علي اساس المكتبة

# PyCLIPS
او 
# pyke
لكن,
الامر استغرق بالفعل اكثر من الوقت المسموح 
كما ان ثقافة الاصدارات لم تكن قائمة لهذا توقف هذا المشروع بعد 5 اشهر من بدايته .
لربما كنت قريبا من الإنجاز. لا اعلم حقا.
ولكن لا اعتقد ان اقوم بإعادة فتحه بعد اليوم. فقط اكتفي بتلك الاستفادة من وراء استخدامهم.
نتجاوز.

لكن اولا اخبرني عن النظام الخبير
?
النظام الخبير ببساطة هو استخلاص كم من المعرفة من انسان ما ثم جعلها قابلة للإسترجاع والتطبيق

طباخ ,؟ عامل , مترجم , أستاذ ؟, طبيب ؟., ضع المجال الذي تريد ,ولكن أكثر الاماكن التي توجد بها النظم الخبيرة هي مصانع الحديد حيث استخدامها في ضبط درجات الحرارة في افران الصهر.وغيره ...

بشكل ابسط أنها الحفاظ علي معرفة هذا الإنسان واستخدامها حتي بعد وفاته؟

هنا النظم الخبيرة في المرحلة الاولي تحتاج الي انسان خبير يكتب معرفته 
iثم مهندس او شخص لديه القدرة علي وضع تلك المعرفة في قاعدة حية قادرة علي اتخاذ القرار بناء علي معرفة الشخص الاول"الخبير"
وهذا هو دورها دوما نسخ قرارات البشر ذو المعرفة.

الغاية النهائية من النظم الخبيرة عموما هو ان يتمكن الشخص العادي من الوصول الي الشخص الخبير من خلال معرفته المخزنه علي الحاسب
لكن الفرق هنا هو امكانية ان يقوم الحاسب بدور الطبيب فعليا ويرد علي المريض بناء علي الطبيب الموجود بداخله."اقصد المعرفة" وهذا مثال علي اماكن استخدامها.,
1-خبير
2-:مهندس معرفة
3-مستخدم عادي <--
تمكين وصول الشخص العادي؟

هكذا اكتملت الصورة تقريبا
""
من وجهة نظر الواقع  ف إن اكثر الاماكن التي تناسب النظم الخبيرة في مجال الطب هي الامراض المزمنة 
السبب ان تلك الامراض الرقمية البسيطة تحتاج دائما الي الملاحظة 
وهم في امس الحاجة الي وجود طبيب معهم بشكل دائم.
قد تقف عقبات كثيرة امامهم لكن العقبة الاكثر تأثيرا هي العقبة النفسية التي تمنعهم من الذهاب بشكل متكرر خاصة في حال صغار السن.الامر صعب التحدث عنه حقا..

حيث انه في حال اردنا بناء نظام خبير متين لداء السكري الرقمي علي سبيل المثال
فسنكون بحاجة الي الخبير التقليدي وهو الطبيب والخبير المتقدم جدا وهو المريض 
لان المريض هو من يجري التجارب علي نفسه ويراقبها بشكل حقيقي بعيدا عن اي دراسات لا تلامس حياته الخاصة جدا.
حيث هنا سيتم تخزين نسبة السكر في الدم علي مدار شهور او سنين كما ان تدوين حالة الخبير المتقدم "المريض"المزاجية عند كل قياس سوف تحكم علي مدي راحته الي الدواء من عدمه او العكس.؟
ان دور الطبيب هو إيجاد منطلق علمي يدعم ملاحظات الخبير المتقدم وربما يتسبب او تسببت هذه الملاحظات في وجود ابحاث تخص الداء الرقمي المذكور .؟

لكن صدق او لا تصدق, لكني اعلم تماما ان هذا من شأنه تحسين المراقبة وتحسين ضبط نسبة الجرعة والتقاط ما إذا كانت ارتفاع  نسبة السكر في الدم او انخفاضه ولفترة طويلة تدخل في طور التأثير بالفعل علي صحة الجسم بشكل عام <الاعراض الجانبيه>, وسيكون العمل هنا بناء علي ما تم تلقيه وتخزينه من معرفة من قبل الخبيرين<الطبيب والمريض>.؟ وملاحظات كليهما لاحقا.
والعمل نحو إيجاد حل أكثر مصداقية وواقعية ,ثم نسخ هذا الامر علي المزيد من الاشخاص ومراقبة النتائج بشكل صريح.
والغاية من تلك الاخيرة هي تجنب الاعراض الجانبية لبعض الامراض المزمنة قدر الإمكان .
 يطمح من سلك هذا الباب الي تحسين حياة الناس بشكل عام اذا تقبلو التعامل مع برنامج بسيط علي هواتفهم.

فكيف نستفيد من خبرات جميعهم الصادقة؟
كيف نكتبها.؟
كيف نستفيد منها؟
كيف سنجعل البيانات مفيدة؟
مهندس المعرفة هو الشخص المنتظر هنا.
نتابع
""

العقبات
عقبات البناء:
دوما كانت هناك مشكلة وهي استخلاص المعرفة التي يمكن بالفعل تطبيقها لانه ليست كل المعرفة قابلة للتنفيذ في حيز الحاسب .

الامر الثاني هو معالج للعقبة الاولي وهو كيف سيكتب الخبير ؟؟
وهل سيكتب اولا قبل ان ياتي الشخص الذي يحولها الي حقائق؟
ام بعد مهندس المعرفة؟..
انقسمت اساليب التطبيق دائما 
فأحيانا يتم كتابة المعرفة  كنصوص بشرية بحتة 
وهنا سيواجه مهندس بناء المعرفة* عقبات كثيرة اهمها هو جهله بتلك المعلومات التي يتوجب عليه استخلاص المعرفة والحقائق منها 

السبب يكمن في ان الذي كتب المعرفة قد يكون طبيب ,فكيف سيستخلصها  الأول؟؟ هل سيدرس المهندس الطب؟
عادة في هذه الحال هو ان يتتبع المهندس سياق الكلمات كما نتتبعه نحن البشر 

لكن سيكون هناك وقتا اطول والاداء يتوقف علي مدي اخلاص المهندس بخصوص  هذا العمل ,أما التطوير نحو الافضل في هذه الحال فهو امر مستحيل علي المهندس.

هذه الحالة هي ان يتم بناء المعرفة بعد كتابة معرفة الخبير ودون اتفاق علي السياق الكتابي لها؟؟؟؟؟
وهنا يتوجب في كل مرة يتم كتابة معرفة جديدة ان يتم استدعاء مهندس المعرفة* لكي ينظر كيف سيستخرج من المعرفة ما يريده ويمكن للحاسب التعامل معه.
انتظر .

الحالة الاخري وهو ان يقوم المهندس بوضع نظام للكتابة وصيغة واضحة المعالم لا يخرج عنها الطبيب
كيف إذن؟
مثلا ان يتم وضع فاصل سواء برمز او بكلمة ثابتة بين كل حقيقة ومعرفة
وهنا هي بمثابة بناء لغة برمجية جديدة
ولا بأس ان يختار الخبير الاسلوب الذي يرتاح اليه في الكتابة وتلك ليست عقبة بالنسبة لمهندس المعرفة
المهم ان يلتزم الطبيب او الخبير بطريقة واحدة للكتابه.

وهنا يمكن للمهندس ان يقوم ببناء قاعدة المعرفة الخاصة بذلك الطبيب مرة واحدة فقط
ولن يحتاج الطبيب ان يعود للمهندس في كل مرة يقوم بكتابة بعض المعرفة الخاصة به

وهنا نرهان علي امرين الامر الاول هو ضمان وجود الشخص الخبير او ضمان وجود شخص يمثل دور الخبير 
حيث يجب ان يكون هذا الشخص قادر علي فهم سياق الجمل والقرارات والحقائق الذي كتبها الخبير بالفعل 
الامر الثاني وهو ميزة وجود الخبير حيث سيكون من السهل بالنسبة له اعادة صياغة معرفته بشكل افضل بناء علي ما يراه من نتائج 
وان هذا هو جعل الاداء في ذروته فعليا.
وهذه الميزة قد لا تتوفر اذا كان الذي يكتب الحقائق شخص ليس له علاقة بالطب علي سبيل المثال.
واقصد من بعيد المهندس الذي يحقق المعرفة للحاسب.
قبل ان نبتعد ربما ان النظم الخيرة ليست بتلك الشهره التي تستحق 
لكن لسنوات كثيرة مضت كان الكتمان علي اساليب متبعة عند بنائها لا ادري مدي الصحة لكن ظلت لسنوات النظم الاكثر كلفة .
لربما هذا سبب قلة المعرفة عنها.
ويمكنك البحث.
{/}
نعود للتطبيق 
https://www.tutorialspoint.com/artificial_intelligence/artificial_intelligence_expert_systems.htm

لنقترب اكثر من واقع المهندس الذي يضع معرفة الطبيب في حيز التنفيذ .بالنسبة للحاسب.

هنا نتحدث عن تحويل معرفة الطبيب الي ما تسمي ب 
"قاعدة المعرفة" + الحقائق

كانت ولا تزال برلوغ هي لغة المعرفة ولغة النظم الخبيرة بشكل كبير السبب من وجهة نظري هو امكانية ان يكتب الخبير بها 
نعم اقصد ان الذي يبني النظم قد يكون الخبير بنفسه دون الحاجة الي مهندس "اعني السهولة النسبية مقارنة مع اللغات الأخري"

صراحة لا اعلم ان هناك احد الخبراء اضطر ليفعل ذلك لكن هي كلغة منطقية واقرب بكثير الي لغة البشر هي بالفعل ابعد ما يكون من اللغات التي تحتاج الي مبرمج بالفعل ليستخدمها.؟

الجدير بالذكر ان الذي قلته هو المفترض ان يكون ,
لكن في الواقع ان لها مبرمجون يتفرغون لها والسبب الاكثر منطقية هو العمل علي بناء نظم خبيرة تستحق الاستخدام والاعتماد عليها .
حيث يتفرغ كل منهم لعمله "المهندس والخبير"
.
يمكنك القاء نظرة علي كيف تبدو  حقائق برلوغ
```
man(ali). 
%% تخزين الاسم علي بصفة ما
man(ali).  
 ->  yes.
%% الاستعلام عن علي واتي بالقبول اي انه موجود
man(jak). 
->   no.
```
%% الاستعلام عن شخص غير موجود تقريبا هكذا يكون الرد

صحيح ان هناك لغات اخري قريبة من تلك بمفهومها الذي لم نتحدث عنه فعليا و يمكنك البحث ,لكن اخترتها لانها الاقرب .
ويمكنك البحث عن طرق كتابتها .؟

لكن ماذا عن بايثون .؟
بايثون بالفعل ليست لغة منطقية و لكي يتم كتابة الحقائق بها وجعلها قادرة علي بناء نظام خبير  يستحق الاعتماد فحقيقة 
حدثت محاولات معدودة لكنها تبقي مميزة للغاية.
هي بالتأكيد عباره عن مكتبات صريحة لبايثون 

المكتبة 
```Pyke 
http://pyke.sourceforge.net/examples.html
```
هي المكتبة الآكثر شمولا من اي مكتبة وجدت في بايثون من اجل هذا المجال .
ولكنها ليست مناسبة كثيرا كبداية اذا ذهبت كثيرا في هذا الطريق قد تعود اليها لتستفيد من عمقها 

المكتبة الاكثر قدما في بايثون والاصعب في الاستخدام ربما 
```PyCLIPS
http://lambda-the-ultimate.org/node/121
```
لن نذهب معها كثيرا فحقيقة لم استخدمها.

نأتي للأهم 
مكتبة واحدة فقط هي من تستحق ان يقال عنها المرونة في الاستخدام والتقدم في الاداء 
```pyknow 
http://pyknow.readthedocs.io/en/stable/thebasics.html
```
هذه المكتبة لاتزال جديدة بالفعل لكن من وجهة نظري هي فعليا حققت السهولة مقارنة ب المكتبات السابق ذكرها 

صحيح ان هناك خيارات قليلة 
لكن بوسعي ان اخبرك انها حقا تكفي 
تكفي الي درجة كبيرة للغاية ان اردت بناء اي نظام خبير.
الجدير بالذكر ان مفهوم الثلاث مكتبات اتي من مكان واحد وربما بني بعضهم علي اساس الاخر.
....................
نأتي للاستخدام في بايثون 3
استدعاء كامل المكتبة 
```

from random import choice
from pyknow import *

class Light(Fact):
    """Info about the traffic light."""
    pass

class RobotCrossStreet(KnowledgeEngine):
    @Rule(Light(color='green'))
    def green_light(self):
        print("Walk")

    @Rule(Light(color='red'))
    def red_light(self):
        print("Don't walk")

    @Rule(AS.light << Light(color=L('yellow') | L('blinking-yellow')))
    def cautious(self, light):
        print("Be cautious because light is", light["color"])

```
هذا اشهر مثال وهو ل اشارة المرور 
حيث تم بناء كلاس فارغ في البداية
ثم بناء كلاس رئيسي يتم استيراد قاعدة المعرفة في راسه
وانتظار الحقائق للأحداث او حالات الالوان المذكورة

```
>>> engine = RobotCrossStreet()
>>> engine.reset()
>>> engine.declare(Light(color=choice(['green', 'yellow', 'blinking-yellow', 'red'])))
>>> engine.run()
Be cautious because light is blinking-yellow

```
هنا بناء محرك لكي يحمل الحقائق من خلال الكلاس الرئيسي
ثم يتم تمرير الالوان اليه بشكل عشوائي عبر اداة
```random as choice```
ونهاية هو تشغيل المحرك فعليا.؟
src
https://github.com/buguroo/pyknow

لربما لايزال الامر مبهم؟؟
اين هي الحقائق واين هي المعرفة؟؟
وكيف يعمل محرك المعرفة؟؟
وهل يذهب في دورة واحدة في كل مرة؟؟

بداية الحقائق وطرق حجزها تختلف عن برلوغ حيث هنا في بايثون يجب التصريح المسبق عن كل شئ لكي تتمكن من استخدامه
في المثال الخاص ب برلوغ استخدمنا الكلمة 
```man```
حقيقة هذه الكلمة ليست موجودة ولم نصرح بها في برلوغ قبل الاستخدام ومع هذا ان برلوغ تعاملت معها بشئ من التلقائية 
لكن بايثون سوف تصدر خطأ يتحدث عن عدم وجود الكلمة 
```man```
انظر كيف تبدو  الحقائق في بايثون؟

```
>>> p = Fact(point=("A",90,8))
>>> p
Fact(point=('A', 90, 8))
>>> p['point']
('A', 90, 8)
>>> type(p)
<class 'pyknow.fact.Fact'>
>>> 

```

هنا تري القواعد 
```
@Rule(myfact)
def tryA():
    print("rule1 --> done")
```
حيث ان القاعدة تختبر الحقائق الموجودة في قاعدة المعرفة مع الحقيقة الموجودة بداخلها وحتي تتطابق معها يتم الدخول الي الدالة الموجودة اسفلها
```tryA()```

تذكر انه يمكنك كتابة اكثر منحقيقة بداخل قاعدة واحدة هكذا مثلا

```@Rule(Fact(point=(A,x,y)) ,Fact( point=(B,x1,y1)),TEST(lambda : (x!=x1)),TEST(lambda : (y!=y1) ))```

وفعليا يوجد في المكتبة الادوات المنطقية امثال 
```AND , OR ,NOT ```
```
@Rule(
    AND(
        OR(User('admin'),
           User('root')),
        NOT(Fact('drop-privileges'))
    )
)
```
اما بالنسبة للكلمة
```TEST```
فهي تمكنك من اجراء اختبار بداخل القواعد ذاتها وربما هذه المرونة ليست موجودة في باقي المكتبات لاحظ هنا مكان 
```lamada```
المناسب للغاية 
الكثير من التفاصيل تجدها في مستندات المكتبة وهناك كتاب بسيط يمر عبر كل جزئية بشكل مختصر 

لكن لنعود للسياق العام
اخبرني عن كيف نعطي مجموعة من الحقائق الي قاعدة المعرفة؟

اول طريقة ولا تفضيل بين اي طريقة لان لكل منهم مكانها الخاص والملائم جدا لها
انظر التالي 
```
class eng(KnowledgeEngine):

    @Rule(Fact(X=80))
    def step1():
          print("step1 done")
```
i---------------------
```
engine = eng()
engine.reset() 
engine.declare(Fact(X = 80))
في السطر السابق قمنا ب الاعلان عن حقيقة واحدة فقط 
engine.run()
```
ثم بعدها قمنا بتشغيل محرك المعرفة  للبحث بداخل قاعدة المعرفة والتي لا يوجد بها سوي الحقيقة المذكورة لكن هل هذه هي الطريقة الوحيدة في تمرير الحقائق؟
هل في كل مرة سنطلب تشغيل المحرك ونعطيه حقيقة جديدة؟ في الواقع لا لانه يمكننا عند كل تنفيذ قاعدة ما ان نقوم ب الاعلان عن حقيقة جديدة او اكثر ويمكننا ايضا ان نقوم ب الإعلان عن مجموعة من الحقائق يتم تخزينها في قاعدة المعرفة مباشرة عند بدء التشغيل 
iانظر لنفس المثال 
```
class eng(KnowledgeEngine):
  @DefFacts()
  def _initial_action(self):
      yield Fact(action="c")
      yield Fact(P=("A",7,90))
      yield Fact(X=("B",33,15))

    @Rule(Fact(X=80))
    def step1():
          print("step1 done")
```
هنا تجد اضافة اسماء جديدة الاسم الاول وهو 
```@DefFacts()```

وهو اعلان عن مجموعة حقائق ضمن قاعدة واجبة النفاذ اي ان البرنامج قبل اي اختبار واي شئ سيقوم ب الدخول الي هذه الكتلة وتنفيذ ما بها 
الكلمة الثانية وهي 
yield

حقيقة هذه الكلمة هي من ضمن كلمات بايثون وتعليماتها الاساسية وهي نظيرة ل 
return 
لكن ما الفرق بينهم الريترن العادية تقوم بحذف القيمة مباشرة بعد التنفيذ وهذا شئ غير مفيد هنا لاننا نريد الابقاء علي الحقائق قيد التنفيذ من المرة الاولي 
وهذه هي مهمة الكلمة 
yield 
حيث انها تعيد القيمة مثل قرينتها لكن لا يتم حذف محتويات الدالة من باقي الحقائق وميزة اخري وهي امكانية اعادة اكثر من حقيقة بداخل دالة واحدة فقط, وايضا يمكنك البحث عن استخدامات اخري لها 

اما بالنسبة الي تمرير حقيقة في حال تحققت احد القواعد
```python
@Rule(Fact(X=80))
    def step1():
          self.declare(Fact(location="Egypt"))
          print("step1 done")
```
لاحظ هنا انه عندما تحققت القاعدة 
```@Rule(Fact(X=80))```
وبالفعل تم الدخول الي الدالة التي تؤشر القاعدة عليها فهنا قمنا ب الاعلان عن حقيقة جديدة 
```self.declare(Fact(location="Egypt"))```

حيث ان 
```self```
تقول التخزين في اصل الكلاس والذي بدوره يمثل قاعدة المعرفة 

```python
class eng(KnowledgeEngine):
```

يعني كانك قلت 
```python
eng.declare(Fact(location="Egypt"))
```

ولكن هذا قد يجوز فقط من خارج الكلاس المذكور نتابع
يجب ان تعلم انه بإمكانك في اي وقت الاستعلام عن مجموعة الحقائق الموجودة في قاعدة المعرفة الاستخدام هو 

```python
print(engine.facts)
```
هذا من خارج الكلاس لكن التالي هو من داخل الكلاس ذاته
```python
print(self.facts)
```
الناتج سيكون تقريبا بهذا الترتيب والشكل لكن اختلاف القيم لديكم

```python
<f-0>: InitialFact()
<f-1>: Fact(point=('A', 809, 100))
<f-2>: Fact(point=('B', 80, 10))
<f-3>: Fact(b='greet') greet
<f-0>: InitialFact()
<f-1>: Fact(point=('A', 809, 100))
<f-2>: Fact(point=('B', 80, 10))
<f-3>: Fact(b='greet')
<f-4>: Fact(point=('A', 5, 55))
<f-5>: Fact(point=('B', 20, 30))
<f-6>: Fact(segment=('A', 'B', 647))
```
هناك امر يجب التنويه عنه وهو عندما تقول ان القاعدة تحمل الحقيقة التالي ذكرها 
```python
@Rule(Fact(med = 900))
```
فانه لن يتم الدخول الي تلك القاعدة حتي تتحقق الحقيقة بداخلها وهي 
```python
Fact(med = 900)
```
اي ان الحقيقة يجب ان تكون بنفس الاسم و القيمة المكتوبة  واقصد 900
```python
declare(Fact(med = 900))
true
but
declare(Fact(med = 902))
false
```
حتي لو تغيرت الي  مجرد 901 ايضا لن يتم الدخول لكن كان هناك تمرير مهم للغاية يتم كتابته في كقيمة للحقيقة الموجودة بداخل القاعدة وهي 
Wildcard Field Constraint

ويتم كتابته هكذا
W()

وفي جملة كاملة يكون هكذا 
@Rule(Fact(med = W()))

في هذه الحالة يتم الدخول الي القاعدة طالما ان اسم القاعدة هو 
med
بغض النظر عن القيمة التي يختزنها فعليا حيث مهما كتبت من قيم فسوف تتحقق القاعدة المذكورة  

```pyhton
declare(Fact(med = 902))
or
declare(Fact(med = 700))
or
declare(Fact(med = 0))
or 
declare(Fact(med = 100000))
or etc.
```


انظر ايضا
```python
@Rule(Fact(mykey=W()))
def _():
    pass
```
الكثير جدا من الخيارات المتاحة في المكتبة لا يمكن الخوض بها أكثر من ذلك هنا لكن تجد الاماكن التي تتحدث عنها بشكل افضل من خلال بحثك او انظر في الوثائق 
```
http://pyknow.readthedocs.io/en/stable/reference.html
https://github.com/Fcmam5/kr-and-expert-system
```
.
#--------------example?

#Expert System for children Diabetes Diagnosis-!!!

بخصوص الامثلة فهناك مثال ملهم يمثل خبير يكشف عن ما اذا كان الطفل مصاب بداء السكري الرقمي من عدمه والتالي هو مثال علي المدخلات المطلوبة بناء علي هيئة الطفل والاعراض التي تظهر عليه بالفعل
``` python
# engine.declare(Personne(age=2,
#                         glycemie=11,
#                         shakiness= False,
#                         hunger= False,
#                         sweating= False,
#                         headach= False,
#                         diabetic_parents = True,
#                         pale= False,
#                         urination = True,
#                         thirst = True,
#                         blurred_vision = False,
#                         dry_mouth = True,
#                         smelling_breath = False,
#                         shortness_of_breath = False,
#                         ))
engine.run()
```
قد تبدو مدخلات مريبة تثير التساؤل حول كيفية تعامل النظام الخبير معها وهناك حيلة من قبل مهندس المعرفة الذي بني المثال المذكور يمكنك استخراجها بنفسك لكنها التفاف من اجل توفير الوقت والجهد وبالفعل النتائج فوق الممتازة التالي هو المكان

https://github.com/Fcmam5/kr-and-expert-system

لكن المهم في المثال السابق ان المعرفة تمت كتابتها الي حقائق مباشرة بعد الجلوس مع الاطباء المختصين بالفعل
``` pyknow ```
شكرا

